# 컴포넌트 최적화

📌 [별코딩 | 리액트 훅스 시리즈](https://youtu.be/G3qglTF-fFI)


📌 [한입 크기로 잘라 먹는 리액트(React.js)](https://www.inflearn.com/course/%ED%95%9C%EC%9E%85-%EB%A6%AC%EC%95%A1%ED%8A%B8)

<br>

## useMemo

<br>

### Memoization?
동일한 값을 리턴하는 함수를 반복적으로 호출 해야할 때 자주 쓰는 값을 맨 처음 계산을 해둬서 그 값이 필요할 때 마다 다시 계산을 하는게 아니라 저장해둔곳에서 꺼내서 사용하는것

<br>

일반적으로 함수형 컴포넌트가 렌더링 될때

렌더링 → component 함수 호출 → 모든 내부 변수 초기화 

☞ 이렇게 되면 무거운 일을 할 때 무의미한 반복이 계속 되서 성능이 떨어질 수 있다.

<br>

**useMemo를 사용하면?**

렌더링 → component 함수 호출, Memoization → 렌더링 → component 함수 호출, Memoize 된 값을 재사용

<br>

```js
const value = useMemo (() => {
    return calculate();
}, [item]);
```

<br>

- 첫번째 인자는 콜백함수 , 우리가 Memoization 할 값을 계산해서 return 해주는 함수, 콜백함수가 return하는 값이 useMemo가 return하는 값
- 두번째 인자는 의존성 배열이라고도 불리는 배열, useMemo는 배열안에 값이 업데이트 될 때만 콜백함수를 다시 호출해서 Memoization 된 값을 업데이트해서 다시 Memoization 해준다.
- [] 빈배열을 넘겨주면 맨 처음 마운트 되었을 때만 값을 계산하고 이후에는 항상 Memoization 된 값을 꺼내와서 사용
- 값이 오브젝트일때 useMemo를 사용해서 초기화 되는것을 막아준다

<br>

### 하지만 useMemo는 꼭 필요할 때만 사용해야한다. 
- 무분별하게 남용하면 성능에 무리가 갈수있다.
- useMemo를 사용한다는건 값을 재활용하기 위해서 따로 메모리를 소비해서 저장을 해놓는건데 불필요한것까지 모두 Memoization하면 성능에 좋지 않을 수 있다.

<br>

## React.memo

- 컴포넌트 성능을 최적화 하는 방법
- 함수형 컴포넌트에게 업데이트 조건을 걸자
- 부모 컴포넌트가 리렌더 되면 자식 컴포넌트도 리렌더 됨 사용하지않은 컴포넌트는 리렌더가 될 필요 없음에도 업데이트되며 리렌더가 되어 연산의 낭비가 일어남 

<br>

**그럼 어떻게 하는게 좋을까?**

각각의 컴포넌트에 업데이트 조건을 주면 됨

<br>

- 함수를 호출해서 매개변수로 컴포넌트를 전달하면 더 좋아진 컴포넌트를 반환해주는 것
- React.memo를 사용하면 전달받은 props의 값이 바뀌지 않으면 리렌더 되지 않음 즉 부모 컴포넌트가 리렌더 하더라도 자신이 전달받은 값과 상관이 없으면 리렌더 되지 않음

<br>

## useCallback 
 
- 컴포넌트 성능을 최적화 하는 방법
- 메모제이션된 콜백을 반환, 인자로 전달한 콜백함수 그 자체를 Memoization 해주는것
- 함수가 필요할 때마다 새로 생성하는게 아니라 메모리에서 가져와서 재사용하는 것
- 컴포넌트가 처음 렌더링 될때만 함수객체를 초기화 해주고 이후에 렌더링 될 때는 새로운 함수객체를 할당 받는게 아니라 이전에 이미 할당받은 함수객체를 계속 가지고 있으면서 재사용하는것

<br>

일반적으로 렌더링 될 때

컴포넌트 렌더링 → component 함수 호출 → 모든 내부 변수 초기화

<br>

**useCallback을 사용하면?**

렌더링 → component 함수 호출 → Memoize 된 함수를 재사용

<br>

**useMemo를 사용하지 않고 useCallback 을 사용하는 이유는 뭘까?**

useMemo는 함수로 되어있어도 사용하면 값이 되어 반환됨 따라서 함수를 자체를 반환해야 하는 경우 useCallback 을 사용함








